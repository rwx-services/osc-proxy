#!/usr/bin/env ruby
# frozen_string_literal: true

require 'bundler/setup'
require 'osc-ruby'
require 'socket'
require 'optparse'

# Parse command line options
options = {
  host: '127.0.0.1',
  port: nil,
  protocol: :tcp,
  framing: :raw # :raw, :length_prefix, :slip
}

# rubocop:disable Metrics/BlockLength
parser = OptionParser.new do |opts|
  opts.banner = 'Usage: bin/send [options] <osc_address> [args...]'
  opts.separator ''
  opts.separator 'Examples:'
  opts.separator '  bin/send -h 127.0.0.1 -p 21600 --tcp /beat/tempo 120'
  opts.separator '  bin/send -h 127.0.0.1 -p 21650 --udp /cue/fire 1 "go"'
  opts.separator '  bin/send -p 21600 /test/message'
  opts.separator ''
  opts.separator 'Options:'

  opts.on('-h', '--host HOST', 'Destination host (default: 127.0.0.1)') do |host|
    options[:host] = host
  end

  opts.on('-p', '--port PORT', Integer, 'Destination port (required)') do |port|
    options[:port] = port
  end

  opts.on('--tcp', 'Use TCP protocol (default)') do
    options[:protocol] = :tcp
  end

  opts.on('--udp', 'Use UDP protocol') do
    options[:protocol] = :udp
  end

  opts.on('--raw', 'Send raw OSC data (default)') do
    options[:framing] = :raw
  end

  opts.on('--length-prefix', 'Prefix with 4-byte length header') do
    options[:framing] = :length_prefix
  end

  opts.on('--slip', 'Use SLIP framing (0xC0 delimiters)') do
    options[:framing] = :slip
  end

  opts.on('--help', 'Show this help message') do
    puts opts
    exit
  end
end
# rubocop:enable Metrics/BlockLength

parser.parse!

# Validate arguments
if ARGV.empty?
  puts 'Error: OSC address required'
  puts parser.help
  exit 1
end

unless options[:port]
  puts 'Error: Port (-p) is required'
  puts parser.help
  exit 1
end

osc_address = ARGV.shift
osc_args = ARGV.map do |arg|
  # Try to parse as number, otherwise treat as string
  case arg
  when /^-?\d+$/
    arg.to_i
  when /^-?\d+\.\d+$/
    arg.to_f
  else
    arg
  end
end

# Create OSC message
message = OSC::Message.new(osc_address, *osc_args)
osc_data = message.encode

# Apply framing for TCP
data = osc_data.dup
if options[:protocol] == :tcp
  case options[:framing]
  when :length_prefix
    # 4-byte big-endian length prefix
    length_prefix = [osc_data.bytesize].pack('N')
    data = length_prefix + osc_data
  when :slip
    # SLIP framing: 0xC0 (END) byte before and after
    slip_end = "\xC0".b
    data = slip_end + osc_data + slip_end
  when :raw
    # No framing, just raw OSC data
    data = osc_data
  end
end

# Display message info
puts '=== Sending OSC Message ==='
puts "Address: #{message.address}"
puts "Args: #{message.to_a.inspect}"
puts "OSC size: #{osc_data.bytesize} bytes"
puts "OSC hex: #{osc_data.unpack1('H*')}"
puts "Protocol: #{options[:protocol].to_s.upcase}"
if options[:protocol] == :tcp
  puts "Framing: #{options[:framing]}"
  puts "Total bytes: #{data.bytesize}" if options[:framing] != :raw
  puts "Full hex: #{data.unpack1('H*')}" if options[:framing] != :raw
end
puts "Destination: #{options[:host]}:#{options[:port]}"
puts

# Send message
begin
  case options[:protocol]
  when :tcp
    socket = TCPSocket.new(options[:host], options[:port])
    socket.write(data)
    socket.flush
    socket.close
    puts "✓ Sent via TCP (#{data.bytesize} bytes)"
  when :udp
    socket = UDPSocket.new
    socket.send(data, 0, options[:host], options[:port])
    socket.close
    puts '✓ Sent via UDP'
  end
rescue StandardError => e
  puts "✗ Failed: #{e.message}"
  exit 1
end
